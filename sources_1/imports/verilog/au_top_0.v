/*
   This file was generated automatically by Alchitry Labs version 1.2.5.
   Do not edit this file directly. Instead edit the original Lucid source.
   This is a temporary file and any changes made to it will be destroyed.
*/

module au_top_0 (input         clk,
                 input         rst_n,
                 output [7:0]  led,
                 input         usb_rx,
                 output        usb_tx,

                 input         io_btn_n, 
                 input         io_btn_s,
                 input         io_btn_e,
                 input         io_btn_w,
                 input         io_btn_c,

                 output [7:0]  io_led1,
                 output [7:0]  io_led2,
                 output [7:0]  io_led3,

                 output [7:0]  io_7seg,
                 output [3:0]  io_7seg_en,

                 inout [15:0]  ddr3_dq,
                 inout [1:0]   ddr3_dqs_n,
                 inout [1:0]   ddr3_dqs_p,
                 output [13:0] ddr3_addr,
                 output [2:0]  ddr3_ba,
                 output        ddr3_ras_n,
                 output        ddr3_cas_n,
                 output        ddr3_we_n,
                 output        ddr3_reset_n,
                 output        ddr3_ck_p,
                 output        ddr3_ck_n,
                 output        ddr3_cke,
                 output        ddr3_cs_n,
                 output [1:0]  ddr3_dm,
                 output        ddr3_odt);
   
   wire                        io_btn_n_cond,
                               io_btn_s_cond,
                               io_btn_e_cond,
                               io_btn_w_cond,
                               io_btn_c_cond;

   wire           ui_clk;
   
   // IO LEDs and buttons
   button_conditioner btn_n(.clk(ui_clk), .btn(io_btn_n), .out(io_btn_n_cond));
   button_conditioner btn_s(.clk(ui_clk), .btn(io_btn_s), .out(io_btn_s_cond));
   button_conditioner btn_e(.clk(ui_clk), .btn(io_btn_e), .out(io_btn_e_cond));
   button_conditioner btn_w(.clk(ui_clk), .btn(io_btn_w), .out(io_btn_w_cond));
   button_conditioner btn_c(.clk(ui_clk), .btn(io_btn_c), .out(io_btn_c_cond));

   reg [7:0]                   counter = 8'h00;

   // Clock wiz
   wire           clk_out1;
   wire           clk_out2;
   wire           clk_locked;

   clk_wiz_0 clk_wiz (.reset(!rst_n),
                      .clk_in1(clk),
                      .clk_out1(clk_out1),
                      .clk_out2(clk_out2),
                      .locked(clk_locked));
   
   // Memory load/store logic
   wire [7:0]                hex_of_counter1;
   wire [7:0]                hex_of_counter2;
   wire [7:0]                hex_of_counter3;
   wire [7:0]                hex_of_counter4;
   sevseg_decode decode1(.in(addr[7:4]), .out(hex_of_counter1));
   sevseg_decode decode2(.in(addr[3:0]), .out(hex_of_counter2));
   sevseg_decode decode3(.in(counter[7:4]), .out(hex_of_counter3));
   sevseg_decode decode4(.in(counter[3:0]), .out(hex_of_counter4));

   wire [31:0]               sevsegdata = {hex_of_counter1, hex_of_counter2, hex_of_counter3, hex_of_counter4};
   
   sevseg sevseg(.clk(ui_clk), .din(sevsegdata), .segments(io_7seg), .digits(io_7seg_en));

   // Default values
   reg wea = 1'b0;
   reg en = 1'b0;
   reg [25:0] addr = 26'h0;     // 2^26 distinct 32-bit blocks
   reg [31:0] din = 32'h000000f0;
   localparam CMD_READ = 1'b1;
   localparam CMD_WRITE = 1'b0;

   reg        cmd = CMD_WRITE;

   // Outputs
   wire [31:0] dout;
   wire        sync_rst;
   wire        cmd_rdy;
   wire        write_rdy;
   wire        read_arrived;
   wire        calibrated;
   memory memory(.wea(wea),
                 .en(en),
                 .addr(addr),
                 .din(din),
                 .dout(dout),
                 .cmd(cmd),
                 .cmd_rdy(cmd_rdy),
                 .write_rdy(write_rdy),
                 .read_arrived(read_arrived),
                 .calibrated(calibrated),

                 .ddr3_dq(ddr3_dq),
                 .ddr3_dqs_n(ddr3_dqs_n),
                 .ddr3_dqs_p(ddr3_dqs_p),
                 .ddr3_addr(ddr3_addr),
                 .ddr3_ba(ddr3_ba),
                 .ddr3_ras_n(ddr3_ras_n),
                 .ddr3_cas_n(ddr3_cas_n),
                 .ddr3_we_n(ddr3_we_n),
                 .ddr3_reset_n(ddr3_reset_n),
                 .ddr3_ck_p(ddr3_ck_p),
                 .ddr3_ck_n(ddr3_ck_n),
                 .ddr3_cke(ddr3_cke),
                 .ddr3_cs_n(ddr3_cs_n),
                 .ddr3_dm(ddr3_dm),
                 .ddr3_odt(ddr3_odt),
                 .sys_clk(clk_out1),
                 .clk_ref(clk_out2),
                 .sys_rst(!clk_locked),
                 .ui_clk(ui_clk),
                 .sync_rst(sync_rst));

   assign rst = sync_rst;

   wire [7:0]  uart_wires;
   wire        uart_data_rdy = 0;
   
   uart uart(.tx(usb_tx),
             .rx(usb_rx),
             .clk(ui_clk),
             .data_out(uart_wires));
/* -----\/----- EXCLUDED -----\/-----
             .data_rdy(uart_data_rdy));
 -----/\----- EXCLUDED -----/\----- */

   assign io_led2 = {5'b0, iostate};

   reg [31:0]   read_buf = 8'h55;
   
   assign led[7:0] = read_buf[7:0];
   
   localparam IO_CALIBRATING = 3'b000;
   localparam IO_READY_FOR_INPUT = 3'b001;
   localparam IO_WAIT_TO_WRITE = 3'b010;
   localparam IO_WRITTEN = 3'b011;
   localparam IO_READ_ADDR = 3'b100;
   localparam IO_WAIT_FOR_RESULTS = 3'b101;

   localparam IO_ADDR_MAX = {18'b0, 8'hff};
   reg [2:0]  iostate = IO_CALIBRATING;

   reg [7:0]  wait_ctr = 8'h00;
   reg [7:0]  wrt_ctr = 8'h00;
   assign io_led1 = counter;
   assign io_led2 = {5'b0, iostate};
   assign io_led3 = wait_ctr;

   always @(posedge ui_clk) begin
      case (iostate)
        IO_CALIBRATING: begin
           if (calibrated)
             iostate <= IO_READY_FOR_INPUT;
        end
        IO_READY_FOR_INPUT: begin
           if (uart_data_rdy) begin
              counter <= uart_wires;
              wrt_ctr <= 8'h00;
              iostate <= IO_WAIT_TO_WRITE;
           end else if (io_btn_e_cond)
             counter <= counter + 1'b1;
           else if (io_btn_w_cond)
             counter <= counter - 1'b1;
           else if (io_btn_c_cond) begin
              wrt_ctr <= 8'h00;
              iostate <= IO_WAIT_TO_WRITE;
           end else if (io_btn_n_cond) begin
              if (addr == IO_ADDR_MAX)
                addr <= 26'b0;
              else
                addr <= addr + 1'b1;
              iostate <= IO_READ_ADDR;
           end else if (io_btn_s_cond) begin
              if (addr == 26'b0)
                addr <= IO_ADDR_MAX;
              else
                addr <= addr - 1'b1;
              iostate <= IO_READ_ADDR;
           end
        end
        IO_WAIT_TO_WRITE: begin
           wrt_ctr <= wrt_ctr + 1'b1;
           if (cmd_rdy & write_rdy) begin
              cmd <= CMD_WRITE;
              din <= {24'h0, counter};
              wea <= 1'b1;
              en <= 1'b1;
              iostate <= IO_WRITTEN;
           end
        end
        IO_WRITTEN: begin
           wrt_ctr <= wrt_ctr + 1'b1;
           if (cmd_rdy) begin
              wea <= 0;
              en <= 0;
              iostate <= IO_READ_ADDR;
           end
        end
        IO_READ_ADDR: begin
          if (cmd_rdy) begin
             cmd <= CMD_READ;
             en <= 1'b1;
             wait_ctr <= 8'h00;
             iostate <= IO_WAIT_FOR_RESULTS;
          end
        end
        IO_WAIT_FOR_RESULTS: begin
           if (cmd_rdy & en) begin
             en <= 1'b0;
           end

           wait_ctr <= wait_ctr + 1'b1;

           if (read_arrived) begin
              read_buf <= dout;
              iostate <= IO_READY_FOR_INPUT;
           end
        end           
      endcase
   end
endmodule
