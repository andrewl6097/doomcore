/*
   This file was generated automatically by Alchitry Labs version 1.2.5.
   Do not edit this file directly. Instead edit the original Lucid source.
   This is a temporary file and any changes made to it will be destroyed.
*/

module au_top_0 (input         clk,
                 input         rst_n,
                 output [7:0]  led,
                 input         usb_rx,
                 output        usb_tx,

                 input         io_btn_n, 
                 input         io_btn_s,
                 input         io_btn_e,
                 input         io_btn_w,
                 input         io_btn_c,

                 output [7:0]  io_led1,
                 output [7:0]  io_led2,
                 output [7:0]  io_led3,

                 output [7:0]  io_7seg,
                 output [3:0]  io_7seg_en,

                 inout [15:0]  ddr3_dq,
                 inout [1:0]   ddr3_dqs_n,
                 inout [1:0]   ddr3_dqs_p,
                 output [13:0] ddr3_addr,
                 output [2:0]  ddr3_ba,
                 output        ddr3_ras_n,
                 output        ddr3_cas_n,
                 output        ddr3_we_n,
                 output        ddr3_reset_n,
                 output        ddr3_ck_p,
                 output        ddr3_ck_n,
                 output        ddr3_cke,
                 output        ddr3_cs_n,
                 output [1:0]  ddr3_dm,
                 output        ddr3_odt);
   
   wire                        io_btn_n_cond,
                               io_btn_s_cond,
                               io_btn_e_cond,
                               io_btn_w_cond,
                               io_btn_c_cond;

   wire           ui_clk;
   
   // IO LEDs and buttons
   button_conditioner btn_n(.clk(ui_clk), .btn(io_btn_n), .out(io_btn_n_cond));
   button_conditioner btn_s(.clk(ui_clk), .btn(io_btn_s), .out(io_btn_s_cond));
   button_conditioner btn_e(.clk(ui_clk), .btn(io_btn_e), .out(io_btn_e_cond));
   button_conditioner btn_w(.clk(ui_clk), .btn(io_btn_w), .out(io_btn_w_cond));
   button_conditioner btn_c(.clk(ui_clk), .btn(io_btn_c), .out(io_btn_c_cond));

   reg [7:0]                   counter = 8'h00;

   // Clock wiz
   wire           clk_out1;
   wire           clk_out2;
   wire           clk_locked;

   clk_wiz_0 clk_wiz (.reset(!rst_n),
                      .clk_in1(clk),
                      .clk_out1(clk_out1),
                      .clk_out2(clk_out2),
                      .locked(clk_locked));
   
   // Memory load/store logic
   wire [7:0]                hex_of_counter1;
   wire [7:0]                hex_of_counter2;
   wire [7:0]                hex_of_counter3;
   wire [7:0]                hex_of_counter4;
   sevseg_decode decode1(.in(addr[15:12]), .out(hex_of_counter1));
   sevseg_decode decode2(.in(addr[11:8]), .out(hex_of_counter2));
   sevseg_decode decode3(.in(addr[7:4]), .out(hex_of_counter3));
   sevseg_decode decode4(.in(addr[3:0]), .out(hex_of_counter4));

   wire [31:0]               sevsegdata = {hex_of_counter1, hex_of_counter2, hex_of_counter3, hex_of_counter4};
   
   sevseg sevseg(.clk(ui_clk), .din(sevsegdata), .segments(io_7seg), .digits(io_7seg_en));

   // Default values
   reg wea = 1'b0;
   reg en = 1'b0;
   reg [25:0] addr = 26'b0;     // 2^26 distinct 32-bit blocks
   reg [31:0] din = 32'h000000f0;
   localparam CMD_READ = 1'b1;
   localparam CMD_WRITE = 1'b0;

   reg        cmd = CMD_WRITE;

   // Outputs
   wire [31:0] dout;
   wire        sync_rst;
   wire        cmd_rdy;
   wire        write_rdy;
   wire        read_arrived;
   wire        calibrated;
   memory memory(.wea(wea),
                 .en(en),
                 .addr(addr),
                 .din(din),
                 .dout(dout),
                 .cmd(cmd),
                 .cmd_rdy(cmd_rdy),
                 .write_rdy(write_rdy),
                 .read_arrived(read_arrived),
                 .calibrated(calibrated),

                 .ddr3_dq(ddr3_dq),
                 .ddr3_dqs_n(ddr3_dqs_n),
                 .ddr3_dqs_p(ddr3_dqs_p),
                 .ddr3_addr(ddr3_addr),
                 .ddr3_ba(ddr3_ba),
                 .ddr3_ras_n(ddr3_ras_n),
                 .ddr3_cas_n(ddr3_cas_n),
                 .ddr3_we_n(ddr3_we_n),
                 .ddr3_reset_n(ddr3_reset_n),
                 .ddr3_ck_p(ddr3_ck_p),
                 .ddr3_ck_n(ddr3_ck_n),
                 .ddr3_cke(ddr3_cke),
                 .ddr3_cs_n(ddr3_cs_n),
                 .ddr3_dm(ddr3_dm),
                 .ddr3_odt(ddr3_odt),
                 .sys_clk(clk_out1),
                 .clk_ref(clk_out2),
                 .sys_rst(!clk_locked),
                 .ui_clk(ui_clk),
                 .sync_rst(sync_rst));

   assign rst = sync_rst;

   wire [7:0]  uart_wires;
   wire        uart_data_rdy;

   wire [7:0]  data_in;
   reg         data_in_en = 1'b0;
   wire        data_in_rdy;

   wire [13:0]  counter_leds;
   wire [7:0]  debug_leds;

   uart uart(.tx(usb_tx),
             .rx(usb_rx),
             .clk(ui_clk),
             .data_out(uart_wires),
             .data_rdy(uart_data_rdy),
             .debug_leds(debug_leds),
             .data_in(data_in),
             .data_in_en(data_in_en),
             .data_in_rdy(data_in_rdy));

   reg [31:0]   read_buf = 8'h55;
   
   localparam CALIBRATING = 4'h0;
   localparam READY_FOR_LENGTH0 = 4'b0001;
   localparam READY_FOR_LENGTH1 = 4'b0010;
   localparam READY_FOR_LENGTH2 = 4'b0011;
   localparam READY_FOR_LENGTH3 = 4'b0100;
   localparam LENGTH_ACK = 4'b0101;
   localparam READY_FOR_BYTE = 4'b0110;
   localparam WAIT_TO_WRITE = 4'b0111;
   localparam WRITTEN = 4'b1000;
   localparam DATA_ACK = 4'b1001;
   localparam FLASHED = 4'b1010;
   
   reg [3:0]  iostate_in = CALIBRATING;
   reg [3:0]  iostate_out = CALIBRATING;

   reg [7:0]  out_buf;
   assign data_in = out_buf;

   reg [1:0]  ack_counter_in = 2'b11;
   reg [1:0]  ack_counter_out = 2'b11;

   reg [31:0] data_length_out = 32'hffff;
   reg [31:0] data_length_in = 32'hffff;

   assign io_led1 = data_length_out[7:0];
   assign io_led2 = uart_wires;
   assign io_led3 = {4'b1111, iostate_out};
   assign led = {6'b0, ack_counter_out};

   reg [31:0] flash_buf;

   always @(posedge ui_clk) begin
      iostate_out <= iostate_in;
      ack_counter_out <= ack_counter_in;
      data_length_out <= data_length_in;
      
      if (rst) begin
         iostate_in <= CALIBRATING;
         addr <= 26'b0;
      end else begin
        case (iostate_out)
          CALIBRATING: begin
             if (calibrated)
               iostate_in <= READY_FOR_LENGTH0;
          end
          READY_FOR_LENGTH0: begin
             if (uart_data_rdy) begin
                data_length_in[31:24] <= uart_wires;
                iostate_in <= READY_FOR_LENGTH1;
             end
          end
          READY_FOR_LENGTH1: begin
             if (uart_data_rdy) begin
                data_length_in[23:16] <= uart_wires;
                iostate_in <= READY_FOR_LENGTH2;
             end
          end
          READY_FOR_LENGTH2: begin
             if (uart_data_rdy) begin
                data_length_in[15:8] <= uart_wires;
                iostate_in <= READY_FOR_LENGTH3;
             end
          end
          READY_FOR_LENGTH3: begin
             if (uart_data_rdy) begin
                data_length_in[7:0] <= uart_wires;
                iostate_in <= LENGTH_ACK;
             end
          end
          LENGTH_ACK: begin
             if (data_in_rdy) begin
                out_buf <= 8'h2b;
                data_in_en <= 1'b1;
                iostate_in <= READY_FOR_BYTE;
                ack_counter_in <= 2'b00;
             end
          end
          READY_FOR_BYTE: begin
             data_in_en <= 1'b0;
             if (uart_data_rdy) begin
                case (ack_counter_out)
                  2'b00: flash_buf[31:24] <= uart_wires;
                  2'b01: flash_buf[23:16] <= uart_wires;
                  2'b10: flash_buf[15:8] <= uart_wires;
                  2'b11: begin
                     flash_buf[7:0] <= uart_wires;
                     iostate_in <= WAIT_TO_WRITE;
                  end
                endcase
                ack_counter_in <= ack_counter_out + 1'b1;
             end
          end
          WAIT_TO_WRITE: begin
             if (cmd_rdy & write_rdy) begin
                cmd <= CMD_WRITE;
                din <= flash_buf;
                wea <= 1'b1;
                en <= 1'b1;
                iostate_in <= WRITTEN;
             end
          end
          WRITTEN: begin
             wea <= 0;
             if (cmd_rdy) begin
                en <= 0;
                iostate_in <= DATA_ACK;
             end
          end
          DATA_ACK: begin
             if (data_in_rdy) begin
                out_buf <= 8'h2e;
                data_in_en <= 1'b1;
                // If there was just one chunk remaining
                if (data_length_out == 32'b1)
                  iostate_in <= FLASHED;
                else begin
                   data_length_in <= data_length_out - 1'b1;
                   addr <= addr + 3'b100;
                   iostate_in <= READY_FOR_BYTE;
                end
             end
          end
          FLASHED: begin
             data_in_en <= 1'b0;
          end
        endcase
      end
   end
endmodule
